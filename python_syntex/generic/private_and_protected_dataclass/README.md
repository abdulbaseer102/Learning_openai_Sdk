Private and Protected Attributes in Python DataClasses
Python, by design, does not have strict enforcement of “private” or “protected” visibility like some other languages (e.g. Java or C++). Instead, Python developers rely on naming conventions (single underscore _ or double underscore __) and sometimes property getters/setters to indicate or simulate restricted access.

We will walk through five illustrative examples, ranging from basic conventions to more advanced usage with data classes.

1. Python’s Visibility Conventions: A Refresher
Before we jump into data classes, let’s recall how Python typically indicates private or protected attributes:

Public Attributes: No leading underscores. Accessible everywhere (e.g. myobject.value).
Protected Attributes (by convention): Single leading underscore (e.g. _secret).
This suggests other developers should not use it externally, but nothing prevents them from doing so.
Private Attributes (by name mangling): Double leading underscore (e.g. __very_secret).
Name mangling: Python automatically renames __very_secret to _<ClassName>__very_secret. This helps avoid accidental overrides in subclasses.
This is still not truly private—you can technically access it by referencing its mangled name, but it’s a strong indicator that it’s internal.
2. Basic DataClass with Underscore Conventions
Example 1: Single Underscore and Double Underscore Fields
Let’s start with a simple data class containing three attributes: public, protected, and private.

from dataclasses import dataclass

@dataclass
class ExampleDataClass:
    public_value: int
    _protected_value: int
    __private_value: int

# Usage
obj = ExampleDataClass(10, 20, 30)
print(obj.public_value)  # Accessible
print(obj._protected_value)  # Accessible but discouraged
print(obj._ExampleDataClass__private_value)  # Name-mangled but accessible
This example demonstrates how Python handles visibility within data classes while adhering to its flexible access conventions.

Example 2: Single Underscore and Double Underscore Fields in a Person Class
from dataclasses import dataclass

@dataclass
class Person:
    name: str                   # Public
    _age: int                   # Protected (convention)
    __bank_account_balance: int # Private (name mangling)
Explanation:
Public Field: name. In normal usage, anyone can do person.name.
Protected Field: _age. By convention, this suggests “internal use.” Another developer can do person._age, but it’s usually frowned upon unless absolutely necessary.
Private Field: __bank_account_balance. Python will automatically rename this to _Person__bank_account_balance internally, providing some limited protection from accidental access.
In Python, attributes that start with two underscores are "mangled" to include the class name (e.g. bank_account_balance becomes _Person__bank_account_balance internally).

This means that when you try to pass bank_account_balance=100 as a keyword argument, it doesn't match the parameter name generated by the dataclass's __init__.